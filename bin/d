#!/usr/bin/env bash

# "d" for done or diary, a plan-like store
# requires sqlite3, fzf (and pandoc, treemd for some output formats, entr for the watch subcommand)
#
# Usage:
#   d           - interactive fzf interface (default)
#   d html      - export all entries to HTML
#   d watch     - watch for changes to this script and auto-refresh browser

DBFILE="$HOME/Dropbox/d.sqlite3"
D_PREVIEW_DIR="$HOME/Downloads/d-preview"
mkdir -p "$D_PREVIEW_DIR"

# Tag helper functions
get_or_create_tag() {
	local tag_path="${1//\'/\'\'}"  # escape quotes
	local tag_name="${2:-${tag_path##*:}}"  # default: last segment of path
	# Capitalize first letter: uriel -> Uriel
	tag_name="$(echo "${tag_name:0:1}" | tr '[:lower:]' '[:upper:]')${tag_name:1}"
	tag_name="${tag_name//\'/\'\'}"
	sqlite3 "$DBFILE" "
		insert into tags(path, name) values('$tag_path', '$tag_name')
		on conflict(path) do update set path=path
		returning id"
}

sync_mentioned_tags() {
	local entry_id="$1"
	local body
	body=$(sqlite3 "$DBFILE" "select body from log where id=$entry_id")

	# Remove old mentioned tags for this entry
	sqlite3 "$DBFILE" "delete from entry_tags where entry_id=$entry_id and relation='mentioned'"

	# Parse d:tag:xxx URIs from body and add them
	echo "$body" | grep -oE 'd:tag:[a-zA-Z0-9_:-]+' | sed 's/^d:tag://' | sort -u | while read -r tag_path; do
		if [ -n "$tag_path" ]; then
			local tag_id
			tag_id=$(get_or_create_tag "$tag_path")
			sqlite3 "$DBFILE" "insert or ignore into entry_tags(entry_id, tag_id, relation) values($entry_id, $tag_id, 'mentioned')"
		fi
	done
}

# Build D_MDLINK_DATA JSON for vim transient menu
# Returns all tags for this entry as insertable links
build_mdlink_data() {
	local entry_id="$1"

	# Get all tags for this entry
	local tags
	tags=$(sqlite3 -json "$DBFILE" "
		select t.path, t.name
		from entry_tags et
		join tags t on t.id = et.tag_id
		where et.entry_id = $entry_id
		order by t.name
		limit 36
	" 2>/dev/null)

	if [ -z "$tags" ] || [ "$tags" = "[]" ]; then
		echo ""
		return
	fi

	echo "{\"header\":\"Tags\",\"items\":$tags}"
}

export_html() {
	local output_file="$D_PREVIEW_DIR/index.html"
	local tmp_entries="$D_PREVIEW_DIR/entries.json"

	# Get all entries as JSON (including tags from entry_tags table)
	sqlite3 -json "$DBFILE" "
		select l.id, l.at, date(l.at) as day,
		       strftime('%Y', l.at) as year,
		       strftime('%m', l.at) as month,
		       strftime('%W', l.at) as week,
		       l.body, l.title,
		       coalesce((
		           select group_concat(t.path, ' ')
		           from entry_tags et
		           join tags t on t.id = et.tag_id
		           where et.entry_id = l.id
		       ), '') as tags
		from log l where l.deleted is null
		order by l.at desc
	" 2>/dev/null > "$tmp_entries" || echo "[]" > "$tmp_entries"

	# Start HTML
	cat > "$output_file" <<'HTML_HEAD'
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>d - diary export</title>
<script type="module">
  // Initialize mermaid for diagrams
  try {
    const { default: mermaid } = await import('https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs');
    mermaid.initialize({ startOnLoad: true, securityLevel: 'loose' });
  } catch (e) {
    console.warn('Mermaid failed:', e);
  }
</script>
<style>
/* Firefox doesn't use fontconfig for file:// URLs due to security policy.
   Explicit @font-face needed. Alternative: about:config -> security.fileuri.strict_origin_policy = false (security risk) */
@font-face {
  font-family: "Go Mono";
  src: url("file:///home/ch/.local/share/fonts/Go/Go-Mono.ttf");
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: "Go Mono";
  src: url("file:///home/ch/.local/share/fonts/Go/Go-Mono-Bold.ttf");
  font-weight: bold;
  font-style: normal;
}
:root {
  --bg: #fff; --fg: #222; --muted: #666; --border: #ccc; --accent: #444;
}
@media (prefers-color-scheme: dark) {
  :root { --bg: #1a1a1a; --fg: #e0e0e0; --muted: #888; --border: #444; --accent: #aaa; }
}
* { box-sizing: border-box; }
body {
  font-family: "Noto Serif", Georgia, "Times New Roman", serif;
  font-size: 1.15rem;
  margin: 0;
  padding: 1rem;
  background: var(--bg);
  color: var(--fg);
  line-height: 1.5;
}
a { color: var(--accent); }
code, pre { font-family: "Go Mono", monospace; }
header {
  width: 100%;
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 20;
  padding: 0.5rem 0;
  margin-top: -0.5rem;
  margin-bottom: 1.5rem;
}
header .header-content {
  display: flex;
  align-items: baseline;
  gap: 1.5rem;
  max-width: 70ch;
  margin: 0 auto;
}
header h1 { margin: 0; flex-shrink: 0; }
header h1 a { color: var(--fg); text-decoration: none; }
header h1 a:hover { text-decoration: underline; }
header nav { font-size: 0.9rem; flex: 1; }
.year-row { margin-bottom: 0.3rem; }
.year-label { font-weight: bold; margin-right: 0.5rem; }
.month-link { margin-right: 0.2rem; text-decoration: none; font-weight: bold; }
.month-link:hover { text-decoration: underline; }
.day-links { font-size: 0.8em; margin-right: 0.5rem; }
.day-links a { color: var(--muted); text-decoration: none; margin-left: 0.15rem; }
.day-links a:hover { text-decoration: underline; color: var(--fg); }
.gap { color: var(--muted); margin: 0 0.3rem; }
article.entry {
  display: block;
  max-width: 70ch;
  margin: 0 auto 2rem;
  padding-bottom: 1rem;
  border-bottom: 1px dotted var(--border);
}
article.entry:last-child { border-bottom: none; }
/* Desktop: date on left, sticky */
@media (min-width: 900px) {
  article.entry {
    display: grid;
    grid-template-columns: 10rem 1fr;
    gap: 1.5rem;
    max-width: calc(70ch + 12rem);
  }
  .entry-sticky {
    /* spans full height of entry, child is sticky inside */
  }
  .entry-date {
    position: sticky;
    top: 4rem;
    text-align: right;
    padding-top: 0.2rem;
  }
  .entry-date time {
    display: block;
    font-size: 0.95rem;
    color: var(--muted);
  }
  .entry-date .month-link {
    display: block;
    font-size: 0.85rem;
    color: var(--muted);
    text-decoration: none;
    font-weight: normal;
  }
  .entry-date .month-link:hover {
    text-decoration: underline;
  }
  .entry-date .rowid {
    display: block;
    font-size: 0.8rem;
    color: var(--muted);
    font-family: "Go Mono", monospace;
    text-decoration: none;
  }
  .entry-date .rowid:hover {
    text-decoration: underline;
  }
  .entry-date .entry-nav {
    display: block;
    font-size: 0.8rem;
    color: var(--muted);
    text-decoration: none;
  }
  .entry-date .entry-nav:hover {
    text-decoration: underline;
    color: var(--fg);
  }
  .entry-date .entry-tags {
    display: block;
    font-size: 0.75rem;
    margin-top: 0.3rem;
  }
  .entry-date .entry-tags a {
    color: var(--muted);
    text-decoration: none;
    display: block;
    text-align: right;
  }
  .entry-date .entry-tags a:hover {
    text-decoration: underline;
    color: var(--fg);
  }
  .entry-main { max-width: 70ch; }
  .entry-title {
    position: sticky;
    top: 4rem;
    background: var(--bg);
    z-index: 5;
  }
  header .header-content { max-width: calc(70ch + 12rem); padding-left: 1rem; padding-right: 1rem; }
}
/* Mobile: date inline */
@media (max-width: 899px) {
  .entry-date {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
  }
  .entry-date time { color: var(--muted); }
  .entry-date .month-link { color: var(--muted); text-decoration: none; font-size: 0.85rem; }
  .entry-date .month-link:hover { text-decoration: underline; }
  .rowid { color: var(--muted); font-family: "Go Mono", monospace; font-size: 0.8rem; text-decoration: none; }
  .rowid:hover { text-decoration: underline; }
  .entry-nav { color: var(--muted); font-size: 0.8rem; text-decoration: none; margin-left: 0.5rem; }
  .entry-nav:hover { text-decoration: underline; }
  .entry-tags { margin-top: 0.3rem; font-size: 0.75rem; }
  .entry-tags a { color: var(--muted); text-decoration: none; margin-right: 0.5rem; }
  .entry-tags a:hover { text-decoration: underline; color: var(--fg); }
}
.entry-content { }
.entry-title > * {
  margin-top: 0;
  color: var(--bg);
  padding: 0.2em 0.5em;
  display: inline-block;
  position: relative;
}
.entry-title > *::before {
  content: '';
  position: absolute;
  inset: -3px -6px;
  background: var(--muted);
  z-index: -1;
  -webkit-mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' preserveAspectRatio='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M2,15 C8,5 18,10 32,7 S52,12 68,6 S88,10 98,16 L97,85 C90,95 78,90 62,93 S42,88 28,94 S12,89 3,83 Z'/%3E%3C/svg%3E");
  mask-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' preserveAspectRatio='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M2,15 C8,5 18,10 32,7 S52,12 68,6 S88,10 98,16 L97,85 C90,95 78,90 62,93 S42,88 28,94 S12,89 3,83 Z'/%3E%3C/svg%3E");
  -webkit-mask-size: 100% 100%;
  mask-size: 100% 100%;
}
.entry-title > * a { color: var(--bg); }
.entry-content blockquote {
  margin: 1rem 0;
  padding: 0.5rem 1rem;
  border-left: 3px solid var(--muted);
  color: var(--muted);
  font-style: italic;
}
.entry-content blockquote > *:first-child { margin-top: 0; }
.entry-content blockquote > *:last-child { margin-bottom: 0; }
.entry-content pre { overflow-x: auto; padding: 0.5rem; }
.entry-content code { font-size: 0.9em; }
.entry-content img { max-width: 100%; }
.entry-content pre.mermaid {
  background: transparent;
  width: min(1500px, calc(100vw - 4rem));
  margin-left: calc(50% - min(750px, 50vw - 2rem));
}
.entry-content pre.mermaid svg {
  width: 100%;
  height: auto;
}
@media (max-width: 1599px) {
  .entry-content pre.mermaid {
    overflow-x: auto;
  }
}
/* Pandoc syntax highlighting (monochrome theme)
   Generated with: pandoc --standalone --highlight-style=monochrome
   then extracted the "code span" rules from the <style> block */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen { div.sourceCode { overflow: auto; } }
code span.al { font-weight: bold; } /* Alert */
code span.an { font-style: italic; } /* Annotation */
code span.cf { font-weight: bold; } /* ControlFlow */
code span.co { font-style: italic; } /* Comment */
code span.cv { font-style: italic; } /* CommentVar */
code span.do { font-style: italic; } /* Documentation */
code span.dt { text-decoration: underline; } /* DataType */
code span.er { font-weight: bold; } /* Error */
code span.in { font-style: italic; } /* Information */
code span.kw { font-weight: bold; } /* Keyword */
code span.pp { font-weight: bold; } /* Preprocessor */
code span.wa { font-style: italic; } /* Warning */
/* Tags in navigation */
.tags-row { margin-bottom: 0.3rem; }
.tags-label { font-weight: bold; margin-right: 0.5rem; cursor: pointer; }
.tags-label:hover { text-decoration: underline; }
.tag-link { margin-right: 0.4rem; text-decoration: none; font-weight: bold; }
.tag-link:hover { text-decoration: underline; }
.tag-link .count { font-weight: normal; color: var(--muted); font-size: 0.9em; }
.tags-overflow { display: none; }
.tags-row.expanded .tags-overflow { display: inline; }
.tags-row.expanded .tags-expand { display: none; }
.tags-expand { color: var(--muted); cursor: pointer; font-size: 0.9em; }
.tags-expand:hover { text-decoration: underline; color: var(--fg); }
/* Filter indication */
body.tag-filtered .entry { display: none; }
body.tag-filtered .entry.tag-match { display: block; }
body.tag-filtered header { border-bottom: 2px solid var(--accent); }
</style>
<script>
(function() {
  function parseHash() {
    const hash = decodeURIComponent(location.hash.slice(1));
    if (!hash.startsWith('d:')) return { type: null, value: null };
    const parts = hash.split(':');
    if (parts[1] === 'tag') return { type: 'tag', value: parts.slice(2).join(':') };
    if (parts[1] === 'date') return { type: 'date', value: parts.slice(2).join(':') };
    if (parts[1] === 'entry') return { type: 'entry', value: parts[2] };
    return { type: null, value: null };
  }

  function filterByTag(tag) {
    const entries = document.querySelectorAll('article.entry');
    document.body.classList.add('tag-filtered');
    entries.forEach(entry => {
      const tags = (entry.dataset.tags || '').split(' ').filter(Boolean);
      const matches = tags.some(t => t === tag || t.startsWith(tag + ':'));
      entry.classList.toggle('tag-match', matches);
    });
  }

  function clearFilter() {
    document.body.classList.remove('tag-filtered');
    document.querySelectorAll('article.entry').forEach(e => e.classList.remove('tag-match'));
  }

  function handleHashChange() {
    const { type, value } = parseHash();
    if (type === 'tag' && value) {
      filterByTag(value);
    } else {
      clearFilter();
    }
  }

  // Clear filter when clicking header
  document.querySelector('header h1 a')?.addEventListener('click', (e) => {
    e.preventDefault();
    history.pushState(null, '', location.pathname);
    clearFilter();
  });

  // Tags expand/collapse
  function setupTagsExpand() {
    const tagsLabel = document.querySelector('.tags-label');
    const tagsExpand = document.querySelector('.tags-expand');
    const tagsRow = document.querySelector('.tags-row');
    if (tagsLabel && tagsRow) {
      tagsLabel.addEventListener('click', () => tagsRow.classList.toggle('expanded'));
    }
    if (tagsExpand && tagsRow) {
      tagsExpand.addEventListener('click', () => tagsRow.classList.add('expanded'));
    }
  }

  window.addEventListener('hashchange', handleHashChange);
  window.addEventListener('DOMContentLoaded', () => {
    handleHashChange();
    setupTagsExpand();
  });
})();
</script>
</head>
<body>
<header>
<div class="header-content">
<h1><a href="#">d</a></h1>
<nav>
HTML_HEAD

	# Generate navigation: group by year/month, show counts and day links
	jq -r '
		group_by(.year + "-" + .month) |
		map({
			year: .[0].year,
			month: (.[0].month | tonumber),
			month_str: .[0].month,
			count: length,
			days: (map(.day) | unique)
		}) |
		group_by(.year) |
		reverse |
		map(
			. as $year_group |
			"<div class=\"year-row\"><span class=\"year-label\">" + .[0].year + ":</span>" +
			([ range(length) | . as $i |
				$year_group[$i] |
				(if $i > 0 and ($year_group[$i-1].month - .month) > 1
				 then "<span class=\"gap\">Â·Â·Â·</span>"
				 else "" end) +
				"<a class=\"month-link\" href=\"#d:date:" + .year + ":" + .month_str + "\">" +
				(if .month == 1 then "Jan"
				 elif .month == 2 then "Feb"
				 elif .month == 3 then "Mar"
				 elif .month == 4 then "Apr"
				 elif .month == 5 then "May"
				 elif .month == 6 then "Jun"
				 elif .month == 7 then "Jul"
				 elif .month == 8 then "Aug"
				 elif .month == 9 then "Sep"
				 elif .month == 10 then "Oct"
				 elif .month == 11 then "Nov"
				 else "Dec" end) +
				"</a><span class=\"day-links\">" +
				(.days | map(
					(. | split("-") | .[2] | ltrimstr("0") | tonumber) as $d |
					(. | gsub("-"; ":")) as $date_uri |
					"<a href=\"#d:date:" + $date_uri + "\">" + ($d | tostring) + "</a>"
				) | join(" ")) +
				"</span>"
			] | reverse | join(" ")) +
			"</div>"
		) | join("\n")
	' "$tmp_entries" >> "$output_file"

	# Generate tag links for navigation (inline, styled like dates)
	local tag_data
	tag_data=$(sqlite3 -json "$DBFILE" "
		select t.path, t.name, count(distinct et.entry_id) as count
		from tags t
		join entry_tags et on et.tag_id = t.id
		join log l on l.id = et.entry_id
		where l.deleted is null
		group by t.id
		order by count desc, t.name asc
	" 2>/dev/null || echo "[]")

	if [ "$tag_data" != "[]" ] && [ -n "$tag_data" ]; then
		echo "$tag_data" | jq -r '
			# Show top 5 inline, rest in overflow span
			. as $all |
			if length == 0 then ""
			else
				"<div class=\"tags-row\"><span class=\"tags-label\">Tags</span>" +
				($all[:5] | map(
					"<a class=\"tag-link\" href=\"#d:tag:" + .path + "\" title=\"" + .path + "\">" + .name + "<span class=\"count\">(" + (.count | tostring) + ")</span></a>"
				) | join("")) +
				(if length > 5 then
					"<span class=\"tags-expand\">+" + ((length - 5) | tostring) + " more</span>" +
					"<span class=\"tags-overflow\">" +
					($all[5:] | map(
						"<a class=\"tag-link\" href=\"#d:tag:" + .path + "\" title=\"" + .path + "\">" + .name + "<span class=\"count\">(" + (.count | tostring) + ")</span></a>"
					) | join("")) +
					"</span>"
				else "" end) +
				"</div>"
			end
		' >> "$output_file"
	fi

	echo '</nav></div></header>' >> "$output_file"

	echo '<!-- ENTRIES -->' >> "$output_file"
	echo '</body></html>' >> "$output_file"

	# Create mermaid filter for pandoc - strip YAML frontmatter from
	# mermaid blocks, otherwise the mermaid parser fails and the diagrams
	# are not rendered
	local mermaid_filter_file="$D_PREVIEW_DIR/d-mermaid-filter.lua"
	cat > "$mermaid_filter_file" <<'FILTER'
function CodeBlock(block)
  if block.classes[1] == "mermaid" then
    local text = block.text
    -- Strip YAML frontmatter (everything between --- and ---) from start of block
    text = text:gsub("^%-%-%-.-%-%-%-\n", "")
    return pandoc.RawBlock("html", "<pre class=\"mermaid\">\n" .. text .. "\n</pre>")
  end
end
FILTER

	# Single jq call: pre-process all entries and output shell assignments directly
	# - Computes prev/next IDs, first-of-day/month flags, weekday/month names
	# - Body and title are base64-encoded to handle newlines/special chars
	# - Tags are expanded to include parent paths for filtering
	local processed_entries
	processed_entries=$(LC_TIME=C jq -r '
		# Helper: expand tags to include parent paths
		# "work:matchi:uriel" -> "work work:matchi work:matchi:uriel"
		def expand_tags:
			if . == "" then ""
			else
				[split(" ")[] | split(":") | [range(1; length+1) as $i | .[0:$i] | join(":")]] | add | unique | join(" ")
			end;

		# Build lookup maps first
		(reduce .[] as $e ({}; if .[$e.day] then . else . + {($e.day): $e.id} end)) as $first_of_day |
		(reduce .[] as $e ({}; ($e.year + "-" + $e.month) as $ym | if .[$ym] then . else . + {($ym): $e.id} end)) as $first_of_month |
		# Store original array for prev/next lookups
		. as $arr |
		# Process each entry, output shell variable assignments
		to_entries | map(
			.key as $i |
			.value as $e |
			($e.day | strptime("%Y-%m-%d") | mktime) as $ts |
			[
				"rowid=\($e.id)",
				"day=\($e.day | @sh)",
				"year=\($e.year | @sh)",
				"month=\($e.month | @sh)",
				"body=\($e.body | @base64)",
				"title=\($e.title | @base64)",
				"tags=\($e.tags | expand_tags | @sh)",
				"raw_tags=\($e.tags | @sh)",
				"prev_rowid=\(if $i > 0 then $arr[$i-1].id else "" end)",
				"next_rowid=\(if $i < ($arr | length) - 1 then $arr[$i+1].id else "" end)",
				"is_first_of_day=\($first_of_day[$e.day] == $e.id)",
				"is_first_of_month=\($first_of_month[$e.year + "-" + $e.month] == $e.id)",
				"weekday=\($ts | strftime("%A") | @sh)",
				"day_num=\($e.day | split("-")[2] | ltrimstr("0"))",
				"month_name=\($ts | strftime("%B") | @sh)"
			] | join(" ")
		) | .[]
	' "$tmp_entries")

	# Accumulate all article HTML in memory
	local all_articles=""

	# Process each entry (one line of shell assignments per entry)
	while IFS= read -r shell_assignments; do
		local rowid day year month body title tags raw_tags prev_rowid next_rowid
		local is_first_of_day is_first_of_month weekday day_num month_name

		# Eval the pre-computed shell assignments (no jq call needed!)
		eval "$shell_assignments"
		# Decode base64 fields
		body=$(echo "$body" | base64 -d)
		title=$(echo "$title" | base64 -d)

		# Convert markdown to HTML with mermaid support
		local entry_html title_html
		entry_html=$(echo "$body" | pandoc -f markdown+fenced_code_attributes -t html --highlight-style=kate --lua-filter "$mermaid_filter_file" 2>/dev/null || echo "$body" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g')
		title_html=$(echo "$title" | pandoc -f markdown -t html 2>/dev/null || echo "$title")

		# Convert d: scheme links to internal anchors
		entry_html=$(echo "$entry_html" | sed 's|href="d:|href="#d:|g')

		# Build anchors with new URI scheme
		local month_anchor="" day_anchor=""
		local day_uri="${day//-/:}"  # 2025-12-18 -> 2025:12:18
		[[ "$is_first_of_month" == "true" ]] && month_anchor="<a id=\"d:date:$year:$month\"></a>"
		[[ "$is_first_of_day" == "true" ]] && day_anchor="<a id=\"d:date:$day_uri\"></a>"

		# Compute ordinal suffix
		local ordinal
		case $day_num in
			1|21|31) ordinal="st" ;;
			2|22) ordinal="nd" ;;
			3|23) ordinal="rd" ;;
			*) ordinal="th" ;;
		esac
		local formatted_date="$weekday, ${day_num}${ordinal}"

		# Build nav links with new URI scheme
		local nav_links=""
		[[ -n "$prev_rowid" ]] && nav_links="<a class=\"entry-nav\" href=\"#d:entry:$prev_rowid\">â†‘ newer</a>"
		[[ -n "$next_rowid" ]] && nav_links="$nav_links<a class=\"entry-nav\" href=\"#d:entry:$next_rowid\">â†“ older</a>"

		# Build tag links from raw_tags
		local tag_links=""
		if [[ -n "$raw_tags" ]]; then
			tag_links="<div class=\"entry-tags\">"
			for tag_path in $raw_tags; do
				# Get display name: last segment of path, capitalize first letter
				local tag_name="${tag_path##*:}"
				tag_name="$(echo "${tag_name:0:1}" | tr '[:lower:]' '[:upper:]')${tag_name:1}"
				tag_links+="<a href=\"#d:tag:$tag_path\" title=\"$tag_path\">$tag_name</a>"
			done
			tag_links+="</div>"
		fi

		# Accumulate article HTML with new URI scheme and data-tags
		all_articles+="$month_anchor$day_anchor<article class=\"entry\" id=\"d:entry:$rowid\" data-tags=\"$tags\">
<div class=\"entry-sticky\">
<div class=\"entry-date\"><time datetime=\"$day\">$formatted_date</time><a class=\"month-link\" href=\"#d:date:$year:$month\">$year $month_name</a><a class=\"rowid\" href=\"#d:entry:$rowid\">#$rowid</a>$nav_links$tag_links</div>
</div>
<div class=\"entry-main\">
<div class=\"entry-content\">
<div class=\"entry-title\">$title_html</div>
$entry_html
</div>
</div>
</article>
"
	done <<< "$processed_entries"

	# Single write: replace marker with all articles
	# Write content to temp file to avoid argument/env size limits
	local tmp_content tmp_out
	tmp_content=$(mktemp)
	tmp_out=$(mktemp)
	printf '%s' "$all_articles" > "$tmp_content"
	awk -v marker="<!-- ENTRIES -->" -v content_file="$tmp_content" '
		$0 ~ marker { while ((getline line < content_file) > 0) print line; close(content_file); next }
		{ print }
	' "$output_file" > "$tmp_out" && mv "$tmp_out" "$output_file"
	rm -f "$tmp_content" "$tmp_out"
	rm -f "$tmp_entries"
}

case "$1" in
	backup)
		if [ -z "$2" ]; then
			echo "usage: d backup <filename>" >&2
			exit 1
		fi
		if ! sqlite3 "$DBFILE" ".backup '$2'"; then
			echo "backup failed" >&2
			exit 1
		fi
		echo "backed up to $2"
		exit 0
		;;
	html)
		export_html
		echo "file://$D_PREVIEW_DIR/index.html"
		exit 0
		;;
	watch)
		# -p postpones, allowing for a debounce-like feature
		echo $0 | entr -p sh -c 'sleep 3; xdg-open $(d html)'
		exit 0
		;;
	perf)
		# Generate flamegraph - requires sudo for perf
		# Use a temp dir for HTML output to avoid creating root-owned files in D_PREVIEW_DIR
		perf_tmp=$(mktemp -d)
		flamegraph_filename="$D_PREVIEW_DIR/d-flame.svg"
		sudo D_PREVIEW_DIR="$perf_tmp" perf record -g -o /tmp/d-perf.data -- bash "$0" html
		sudo perf script -i /tmp/d-perf.data | stackcollapse-perf.pl | flamegraph.pl > "$flamegraph_filename"
		sudo rm -rf /tmp/d-perf.data "$perf_tmp"
		echo "flamegraph: $flamegraph_filename"
		xdg-open "$flamegraph_filename"
		exit 0
		;;
	tag)
		# Tag management for a specific entry
		entry_id="$2"
		if [ -z "$entry_id" ]; then
			echo "usage: d tag <entry_id>" >&2
			exit 1
		fi

		# Get current tags for display
		current_tags=$(sqlite3 "$DBFILE" "
			select t.path || ' [' || et.relation || ']'
			from entry_tags et
			join tags t on t.id = et.tag_id
			where et.entry_id = $entry_id
			order by et.relation, t.path
		" | tr '\n' ', ' | sed 's/,$//')

		# Get all existing tags for completion
		all_tags=$(sqlite3 "$DBFILE" "select path from tags order by path")

		# FZF for tag selection/creation
		selected=$(echo "$all_tags" | fzf \
			--header "Entry #$entry_id tags: $current_tags" \
			--print-query \
			--prompt "Add tag (or type new): " \
			--preview "$0 preview-tag {}" \
			--bind "ctrl-r:execute($0 untag $entry_id {})+abort")

		if [ -n "$selected" ]; then
			# Use query if no match selected, otherwise use selection
			tag_path=$(echo "$selected" | tail -1)
			[ -z "$tag_path" ] && tag_path=$(echo "$selected" | head -1)

			if [ -n "$tag_path" ]; then
				tag_id=$(get_or_create_tag "$tag_path")
				sqlite3 "$DBFILE" "insert or ignore into entry_tags(entry_id, tag_id, relation) values($entry_id, $tag_id, 'tagged')"
				echo "Tagged #$entry_id with '$tag_path'"
			fi
		fi
		exit 0
		;;
	untag)
		# Remove explicit tag from entry
		entry_id="$2"
		tag_path="$3"
		if [ -z "$entry_id" ] || [ -z "$tag_path" ]; then
			echo "usage: d untag <entry_id> <tag_path>" >&2
			exit 1
		fi
		sqlite3 "$DBFILE" "
			delete from entry_tags
			where entry_id = $entry_id
			and tag_id = (select id from tags where path = '$tag_path')
			and relation = 'tagged'
		"
		echo "Removed tag '$tag_path' from #$entry_id"
		exit 0
		;;
	tags)
		# Browse all tags with entry counts
		sqlite3 -separator $'\t' "$DBFILE" "
			select t.path, t.name, count(distinct et.entry_id) as count
			from tags t
			join entry_tags et on et.tag_id = t.id
			join log l on l.id = et.entry_id
			where l.deleted is null
			group by t.id
			order by count desc, t.path
		" | fzf \
			--delimiter=$'\t' \
			--with-nth=1,3 \
			--preview "$0 preview-tag {1}" \
			--bind "enter:become($0 bytag {1})"
		exit 0
		;;
	preview-tag)
		# Preview entries for a tag (used by fzf)
		tag_path="$2"
		sqlite3 "$DBFILE" "
			select l.id, l.at, substr(l.title, 1, 60), et.relation
			from log l
			join entry_tags et on et.entry_id = l.id
			join tags t on t.id = et.tag_id
			where t.path = '$tag_path'
			and l.deleted is null
			order by l.at desc
			limit 20
		"
		exit 0
		;;
	bytag)
		# Show entries for a specific tag (including subtags)
		tag_path="$2"
		if [ -z "$tag_path" ]; then
			echo "usage: d bytag <tag_path>" >&2
			exit 1
		fi

		sqlite3 -separator $'\t' "$DBFILE" "
			select distinct l.id, l.at, l.title, group_concat(distinct et.relation)
			from log l
			join entry_tags et on et.entry_id = l.id
			join tags t on t.id = et.tag_id
			where (t.path = '$tag_path' or t.path like '$tag_path:%')
			and l.deleted is null
			group by l.id
			order by l.at desc
		" | fzf \
			--delimiter=$'\t' \
			--header "Entries tagged with '$tag_path' (and subtags)" \
			--with-nth=2,3,4 \
			--preview "sqlite3 \"$DBFILE\" \"select entry from log where id={1}\" | head -n20 | glow" \
			--bind "enter:execute(sqlite3 \"$DBFILE\" \"update log set entry = trim(trim(edit(entry), X'0A')) where id={1}\")+become($0 bytag $tag_path)" \
			--bind "ctrl-t:execute($0 tag {1})+become($0 bytag $tag_path)"
		exit 0
		;;
	sync-entry-tags)
		# Sync mentioned tags for a single entry
		entry_id="$2"
		if [ -n "$entry_id" ]; then
			sync_mentioned_tags "$entry_id"
		fi
		exit 0
		;;
	sync-all-tags)
		# Sync mentioned tags from all entry bodies
		echo "Syncing mentioned tags from all entries..."
		sqlite3 "$DBFILE" "select id from log where deleted is null" | while read -r entry_id; do
			sync_mentioned_tags "$entry_id"
		done
		echo "Done."
		exit 0
		;;
	build-mdlink)
		# Build D_MDLINK_DATA JSON for an entry (used by fzf binding)
		build_mdlink_data "$2"
		exit 0
		;;
esac

if [ ! -f "$DBFILE" ]; then
	DB_VERSION=0
else
	DB_VERSION=$(sqlite3 "$DBFILE" "select value from meta where key = 'db_version'" 2>/dev/null || echo 0)
fi

while true; do
	case $DB_VERSION in
		0)
			# soft delete because... I forgot about the shortcut and dropped a couple of rows :(
			sqlite3 "$DBFILE" "create table if not exists log(user text, at text default (datetime('now')), entry text, deleted text default null)"
			sqlite3 "$DBFILE" "create table if not exists meta(key text not null unique, value text not null)"
			;;
		1)
			# add id primary key, not null to at and entry, check constraint on entry, generated title column
			sqlite3 "$DBFILE" "
				begin transaction;
				create table log_new(
					id integer primary key autoincrement,
					user text,
					at text not null default (datetime('now')),
					entry text not null check(length(trim(entry)) >= 1),
					deleted text default null,
					title text generated always as (
						trim(
							case
								when instr(trim(entry), char(10)) > 0
								then substr(trim(entry), 1, instr(trim(entry), char(10)) - 1)
								else trim(entry)
							end
						)
					) stored
				);
				insert into log_new(id, user, at, entry, deleted) select rowid, user, at, entry, deleted from log;
				drop table log;
				alter table log_new rename to log;
				commit;
			"
			;;
		2)
			# add body generated column (entry without first line)
			sqlite3 "$DBFILE" "
				begin transaction;
				create table log_new(
					id integer primary key autoincrement,
					user text,
					at text not null default (datetime('now')),
					entry text not null check(length(trim(entry)) >= 1),
					deleted text default null,
					title text generated always as (
						trim(
							case
								when instr(trim(entry), char(10)) > 0
								then substr(trim(entry), 1, instr(trim(entry), char(10)) - 1)
								else trim(entry)
							end
						)
					) stored,
					body text generated always as (
						case
							when instr(trim(entry), char(10)) > 0
							then trim(substr(trim(entry), instr(trim(entry), char(10)) + 1))
							else ''
						end
					) stored
				);
				insert into log_new(id, user, at, entry, deleted) select id, user, at, entry, deleted from log;
				drop table log;
				alter table log_new rename to log;
				commit;
			"
			;;
		3)
			# Add N:N tag support
			sqlite3 "$DBFILE" "
				begin transaction;

				-- Tags table with hierarchical paths like 'work:matchi:uriel'
				create table tags(
					id integer primary key autoincrement,
					path text not null unique collate nocase,
					name text not null,
					created_at text not null default (datetime('now'))
				);

				-- Junction table for N:N relationship
				-- relation: 'tagged' = explicit, 'mentioned' = found in body as d:tag:xxx
				create table entry_tags(
					entry_id integer not null references log(id) on delete cascade,
					tag_id integer not null references tags(id) on delete cascade,
					relation text not null check(relation in ('tagged', 'mentioned')),
					created_at text not null default (datetime('now')),
					primary key (entry_id, tag_id, relation)
				);

				create index idx_entry_tags_entry on entry_tags(entry_id);
				create index idx_entry_tags_tag on entry_tags(tag_id);
				create index idx_tags_path on tags(path);

				commit;
			"
			;;
		*)
			break
			;;
	esac
	if [ $? -ne 0 ]; then
		echo "failed to migrate to step $((DB_VERSION + 1)), exiting" >&2
		exit 1
	fi
	DB_VERSION=$((DB_VERSION + 1))
	sqlite3 "$DBFILE" "insert into meta(key, value) values('db_version', '$DB_VERSION') on conflict(key) do update set value = '$DB_VERSION'"
done

read -r -d '' sql_entries <<EOF
with da as (
	select id, julianday('now')-julianday(at) as days from log
)
select
case when da.days <=3 then 'ðŸ†• ' else '' end as icon,
l.id,
l.at,
l.entry
from log l
inner join da
on da.id = l.id
where l.deleted is null
order by l.at desc;
EOF

read -r -d '' mermaid_header <<'MERMAID_EOF'
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
MERMAID_EOF

read -r -d '' mermaid_filter <<'FILTER_EOF'
function CodeBlock(block)
  if block.classes[1] == "mermaid" then
    local text = block.text
    -- Remove config section from YAML frontmatter if present, otherwise we will syntax error
    text = text:gsub("(%-%-%-%s*\ntitle:[^\n]*\n)config:%s*\n%s*layout:[^\n]*\n(%-%-%-%s*\n)", "%1%2")
    return pandoc.RawBlock("html", "<pre class=\"mermaid\">\n" .. text .. "\n</pre>")
  end
end
FILTER_EOF

echo "$mermaid_header" > "$D_PREVIEW_DIR/d-mermaid-header.html"
echo "$mermaid_filter" > "$D_PREVIEW_DIR/d-mermaid-filter.lua"

# sqlite's edit() opens the editor configurued in VISUAL
# (i.e. `export VISUAL=vim` in your bashrc/zshrc); if vim, hint that we're
# editing markdown
if [ "$VISUAL" = "vim" ]; then
	VISUAL="vim -c 'set filetype=markdown'"
fi


sqlite3 -json "$DBFILE" "$sql_entries" |
	jq -r '.[] | "\(.id)\t\(.entry | gsub("\n"; " ") | gsub("\t"; " ") | gsub("\r"; " "))\t\(.at)\t\(.icon)"' |
	fzf --ansi \
	--style=full \
	--color=light \
	--delimiter=$'\t' \
	--border \
	--border-label ' done [ tab -> create; enter -> edit; shift-tab -> browser; ctrl-a -> treemd; ctrl-d -> delete; ctrl-t -> tag; ctrl-g -> tags; esc -> close ]' \
	--padding 1,2 \
	--bind 'focus:transform-preview-label:[[ -n {} ]] && printf " %sfrom %s " {4} {3}' \
	--bind "tab:execute@sqlite3 $DBFILE \"insert into log(user, entry) values ('\$USER', trim(trim(edit(''), X'0A')))\" && $0 sync-entry-tags \$(sqlite3 $DBFILE 'select last_insert_rowid()')@+become(d)" \
	--bind "ctrl-d:execute@sqlite3 $DBFILE \"update log set deleted=datetime('now') where id={1}\"@+become(d)" \
	--bind "enter:execute@export D_MDLINK_DATA=\"\$($0 build-mdlink {1})\"; sqlite3 $DBFILE \"update log set entry = trim(trim(edit(entry), X'0A')) where id={1}\"; $0 sync-entry-tags {1}@+become(d)" \
	--bind "shift-tab:execute@$0 html >/dev/null && xdg-open $D_PREVIEW_DIR/index.html@+become(d)" \
	--bind "ctrl-a:execute@treemd <(sqlite3 $DBFILE \"select entry from log where id={1}\")@+become(d)" \
	--bind "ctrl-t:execute@$0 tag {1}@+become(d)" \
	--bind "ctrl-g:become($0 tags)" \
	--with-nth=2 \
	--accept-nth=1 \
	--preview "sqlite3 $DBFILE \"select entry from log where id={1}\" | head -n10 | glow"

# X'0A' is \n, i.e. trim newlines, while trim() removes leading & trailing spaces

